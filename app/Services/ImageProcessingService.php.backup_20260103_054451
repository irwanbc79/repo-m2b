<?php

namespace App\Services;

use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

class ImageProcessingService
{
    protected $maxWidth = 1920;
    protected $maxHeight = 1920;
    protected $quality = 80;
    protected $thumbnailSize = 400;

    /**
     * Process uploaded image file
     */
    public function processUpload(UploadedFile $file, int $shipmentId, int $userId): array
    {
        // Generate unique filename
        $extension = $this->getImageExtension($file);
        $filename = Str::uuid() . '.' . $extension;
        $directory = 'field-photos/' . date('Y/m') . '/' . $shipmentId;
        
        // Create directories if not exist
        Storage::disk('public')->makeDirectory($directory);
        Storage::disk('public')->makeDirectory($directory . '/thumbnails');
        
        // Get original image info
        $originalPath = $file->getRealPath();
        $imageInfo = @getimagesize($originalPath);
        
        if ($imageInfo === false) {
            // If can't read image info, just store as-is
            $path = $file->storeAs($directory, $filename, 'public');
            
            return [
                'path' => $path,
                'thumbnail_path' => $path,
                'size' => $file->getSize(),
                'mime_type' => $file->getMimeType(),
                'width' => null,
                'height' => null,
            ];
        }
        
        [$originalWidth, $originalHeight, $imageType] = $imageInfo;
        
        // Load image based on type
        $sourceImage = $this->loadImage($originalPath, $imageType);
        
        if ($sourceImage === null) {
            // Fallback: store original without processing
            $path = $file->storeAs($directory, $filename, 'public');
            
            return [
                'path' => $path,
                'thumbnail_path' => $path,
                'size' => $file->getSize(),
                'mime_type' => $file->getMimeType(),
                'width' => $originalWidth,
                'height' => $originalHeight,
            ];
        }
        
        // Fix orientation from EXIF (for mobile photos)
        $sourceImage = $this->fixOrientation($sourceImage, $originalPath);
        
        // Get dimensions after orientation fix
        $width = imagesx($sourceImage);
        $height = imagesy($sourceImage);
        
        // Resize if needed
        $resizedImage = $this->resizeImage($sourceImage, $width, $height, $this->maxWidth, $this->maxHeight);
        $newWidth = imagesx($resizedImage);
        $newHeight = imagesy($resizedImage);
        
        // Add watermark
        $watermarkedImage = $this->addWatermark($resizedImage, $shipmentId);
        
        // Save main image
        $mainPath = storage_path('app/public/' . $directory . '/' . $filename);
        $this->saveImage($watermarkedImage, $mainPath, $extension);
        
        // Create thumbnail
        $thumbnailImage = $this->resizeImage($sourceImage, $width, $height, $this->thumbnailSize, $this->thumbnailSize);
        $thumbnailFilename = 'thumb_' . $filename;
        $thumbnailPath = storage_path('app/public/' . $directory . '/thumbnails/' . $thumbnailFilename);
        $this->saveImage($thumbnailImage, $thumbnailPath, $extension);
        
        // Free memory
        imagedestroy($sourceImage);
        imagedestroy($resizedImage);
        imagedestroy($watermarkedImage);
        imagedestroy($thumbnailImage);
        
        // Get final file size
        $fileSize = filesize($mainPath);
        
        return [
            'path' => $directory . '/' . $filename,
            'thumbnail_path' => $directory . '/thumbnails/' . $thumbnailFilename,
            'size' => $fileSize,
            'mime_type' => 'image/' . $extension,
            'width' => $newWidth,
            'height' => $newHeight,
        ];
    }

    /**
     * Get proper extension for the image
     */
    protected function getImageExtension(UploadedFile $file): string
    {
        $mimeType = $file->getMimeType();
        $extension = strtolower($file->getClientOriginalExtension());
        
        // Handle HEIC/HEIF - convert to JPEG
        if (in_array($extension, ['heic', 'heif']) || str_contains($mimeType, 'heic') || str_contains($mimeType, 'heif')) {
            return 'jpg';
        }
        
        // Map mime types to extensions
        $mimeMap = [
            'image/jpeg' => 'jpg',
            'image/png' => 'png',
            'image/gif' => 'gif',
            'image/webp' => 'webp',
        ];
        
        return $mimeMap[$mimeType] ?? 'jpg';
    }

    /**
     * Load image from file
     */
    protected function loadImage(string $path, int $imageType)
    {
        switch ($imageType) {
            case IMAGETYPE_JPEG:
                return @imagecreatefromjpeg($path);
            case IMAGETYPE_PNG:
                return @imagecreatefrompng($path);
            case IMAGETYPE_GIF:
                return @imagecreatefromgif($path);
            case IMAGETYPE_WEBP:
                if (function_exists('imagecreatefromwebp')) {
                    return @imagecreatefromwebp($path);
                }
                return null;
            default:
                return null;
        }
    }

    /**
     * Fix image orientation based on EXIF data
     */
    protected function fixOrientation($image, string $path)
    {
        if (!function_exists('exif_read_data')) {
            return $image;
        }
        
        $exif = @exif_read_data($path);
        
        if (!$exif || !isset($exif['Orientation'])) {
            return $image;
        }
        
        switch ($exif['Orientation']) {
            case 3:
                return imagerotate($image, 180, 0);
            case 6:
                return imagerotate($image, -90, 0);
            case 8:
                return imagerotate($image, 90, 0);
            default:
                return $image;
        }
    }

    /**
     * Resize image maintaining aspect ratio
     */
    protected function resizeImage($sourceImage, int $width, int $height, int $maxWidth, int $maxHeight)
    {
        // Calculate new dimensions
        $ratio = min($maxWidth / $width, $maxHeight / $height);
        
        if ($ratio >= 1) {
            // No need to resize
            $newImage = imagecreatetruecolor($width, $height);
            imagealphablending($newImage, false);
            imagesavealpha($newImage, true);
            imagecopy($newImage, $sourceImage, 0, 0, 0, 0, $width, $height);
            return $newImage;
        }
        
        $newWidth = (int) round($width * $ratio);
        $newHeight = (int) round($height * $ratio);
        
        // Create new image
        $newImage = imagecreatetruecolor($newWidth, $newHeight);
        
        // Preserve transparency for PNG
        imagealphablending($newImage, false);
        imagesavealpha($newImage, true);
        $transparent = imagecolorallocatealpha($newImage, 255, 255, 255, 127);
        imagefilledrectangle($newImage, 0, 0, $newWidth, $newHeight, $transparent);
        
        // Resize
        imagecopyresampled(
            $newImage, $sourceImage,
            0, 0, 0, 0,
            $newWidth, $newHeight,
            $width, $height
        );
        
        return $newImage;
    }

    /**
     * Add watermark to image
     */
    protected function addWatermark($image, int $shipmentId)
    {
        $width = imagesx($image);
        $height = imagesy($image);
        
        // Watermark text
        $text = 'SHP-' . $shipmentId . ' | ' . date('d/m/Y H:i');
        
        // Set font size based on image size
        $fontSize = max(2, min(5, (int) ($width / 200)));
        
        // Colors
        $bgColor = imagecolorallocatealpha($image, 0, 0, 0, 80); // Semi-transparent black
        $textColor = imagecolorallocate($image, 255, 255, 255); // White
        
        // Calculate text dimensions (approximate)
        $textWidth = imagefontwidth($fontSize) * strlen($text);
        $textHeight = imagefontheight($fontSize);
        
        // Position at bottom-right
        $padding = 10;
        $x = $width - $textWidth - $padding;
        $y = $height - $textHeight - $padding;
        
        // Draw background rectangle
        imagefilledrectangle(
            $image,
            $x - 5,
            $y - 2,
            $width - $padding + 5,
            $height - $padding + 2,
            $bgColor
        );
        
        // Draw text
        imagestring($image, $fontSize, $x, $y, $text, $textColor);
        
        return $image;
    }

    /**
     * Save image to file
     */
    protected function saveImage($image, string $path, string $extension): bool
    {
        switch ($extension) {
            case 'jpg':
            case 'jpeg':
                return imagejpeg($image, $path, $this->quality);
            case 'png':
                return imagepng($image, $path, 9);
            case 'gif':
                return imagegif($image, $path);
            case 'webp':
                if (function_exists('imagewebp')) {
                    return imagewebp($image, $path, $this->quality);
                }
                return imagejpeg($image, $path, $this->quality);
            default:
                return imagejpeg($image, $path, $this->quality);
        }
    }

    /**
     * Delete photo files
     */
    public function deletePhoto($fieldPhoto): bool
    {
        try {
            if ($fieldPhoto->file_path) {
                Storage::disk('public')->delete($fieldPhoto->file_path);
            }
            if ($fieldPhoto->thumbnail_path) {
                Storage::disk('public')->delete($fieldPhoto->thumbnail_path);
            }
            return true;
        } catch (\Exception $e) {
            \Log::error('Failed to delete photo files', [
                'error' => $e->getMessage(),
                'photo_id' => $fieldPhoto->id
            ]);
            return false;
        }
    }
}
